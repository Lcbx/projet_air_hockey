<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: Cadriciel/Commun/Utilitaire/OpenGL/AideGL.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_aide_g_l_8cpp_source.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">AideGL.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_aide_g_l_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="_aide_g_l_8h.html">AideGL.h</a>&quot;</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="_utilitaire_8h.html">Utilitaire.h</a>&quot;</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="preprocessor">#ifdef WIN32</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;windows.h&gt;</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;FreeImage.h&quot;</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#include &quot;GL/glew.h&quot;</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#include &quot;glm\glm.hpp&quot;</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceaidegl.html">aidegl</a> {</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno"><a class="line" href="namespaceaidegl.html#a465185be937173fdd623eb88949b212c">   45</a></span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="namespaceaidegl.html#a465185be937173fdd623eb88949b212c">creerContexteGL</a>(HWND hWnd, HDC&amp; hDC, HGLRC&amp; hRC)</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    {</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        <span class="comment">// Obtention du &quot;Device context&quot;</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        hDC = ::GetDC(hWnd);</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        <span class="keywordflow">if</span> (hDC == <span class="keyword">nullptr</span>) {</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        }</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <span class="comment">// On choisit le format pour le &quot;Device context&quot;</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        PIXELFORMATDESCRIPTOR pfd;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        ::ZeroMemory(&amp;pfd, <span class="keyword">sizeof</span>(pfd));</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        pfd.nSize = <span class="keyword">sizeof</span>(pfd);</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        pfd.nVersion = 1;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        pfd.dwFlags = PFD_DRAW_TO_WINDOW |</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            PFD_SUPPORT_OPENGL |</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;            PFD_DOUBLEBUFFER;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        pfd.iPixelType = PFD_TYPE_RGBA;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        pfd.cColorBits = 24;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        pfd.cDepthBits = 16;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        pfd.cStencilBits = 1;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        pfd.iLayerType = PFD_MAIN_PLANE;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;        <span class="keywordtype">int</span> format{ ::ChoosePixelFormat(hDC, &amp;pfd) };</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        <span class="keywordflow">if</span> (format == 0) {</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;            ::ReleaseDC(hWnd, hDC);</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;            hDC = 0;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;        }</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        <span class="keywordflow">if</span> (!::SetPixelFormat(hDC, format, &amp;pfd)) {</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;            ::ReleaseDC(hWnd, hDC);</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;            hDC = 0;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        }</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <span class="comment">// Création du contexte</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        hRC = ::wglCreateContext(hDC);</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <span class="keywordflow">if</span> (hRC == 0) {</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;            ::ReleaseDC(hWnd, hDC);</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            hDC = 0;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        }</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        <span class="comment">// Activation du contexte</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="keywordflow">if</span> (!::wglMakeCurrent(hDC, hRC)) {</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            ::wglDeleteContext(hRC);</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;            hRC = 0;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            ::ReleaseDC(hWnd, hDC);</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;            hDC = 0;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        }</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        <span class="comment">// Tout s&#39;est bien passé         return true;
    }


    ////////////////////////////////////////////////////////////////////////
    ///
    /// @fn bool detruireContexteGL(HWND hWnd, HDC hDC, HGLRC hRC)
    ///
    /// Cette fonction détruit proprement un contexte OpenGL.
    ///
    /// @param[in] hWnd : Poignée (&quot;handle&quot;) vers la fenêtre du contexte à détruire.
    /// @param[in] hDC  : Poignée (&quot;handle&quot;) vers le &quot;Device context&quot; de la fenêtre.
    /// @param[in] hRC  : Poignée (&quot;handle&quot;) vers le contexte OpenGL à détruire.
    ///
    /// @return Vrai en cas de succès.
    ///
    ////////////////////////////////////////////////////////////////////////
    bool detruireContexteGL(HWND hWnd, HDC hDC, HGLRC hRC)
    {
        bool succes = true;

        if (!::wglMakeCurrent(0, 0))
            succes = false;

        if (!::wglDeleteContext(hRC))
            succes = false;

        if (::ReleaseDC(hWnd, hDC) == 0)
            succes = false;

        return succes;
    }


    ////////////////////////////////////////////////////////////////////////
    ///
    /// @fn void initialiserRectangleElastique(const glm::ivec2&amp; point, unsigned short patron, int facteur)
    ///
    /// Cette fonction initialise le mode de rendu du rectangle élastique en
    /// mode XOR en sauvegardant l&#39;état de la machine OpenGL et en la modifiant
    /// pour que le rendu soit correct.
    ///
    /// @param[in] point   : Point initial de localisation du rectangle.
    /// @param[in] patron  : Patron de pointillé pour les lignes du rectangle.
    /// @param[in] facteur : Facteur du pointillé pour les lignes du rectangle.
    ///
    /// @return Aucune.
    ///
    ////////////////////////////////////////////////////////////////////////
    void initialiserRectangleElastique(
        const glm::ivec2&amp; point,
        unsigned short   patron, //= 0x3333
        int              facteur //= 1
        )
    {
        // On sauvegarde les attributs de traçage.
        glPushAttrib(GL_LINE_BIT |
            GL_CURRENT_BIT |
            GL_COLOR_BUFFER_BIT |
            GL_DEPTH_BUFFER_BIT);

        // On dessine uniquement dans ce qui est déjà à l&#39;écran.
        glDrawBuffer(GL_FRONT);

        // On désactive le test de profondeur et les textures.
        glDisable(GL_DEPTH_TEST);
        glDisable(GL_TEXTURE_2D);

        // On sauvegarde les matrices de transformation.
        glMatrixMode(GL_MODELVIEW);
        glPushMatrix();
        glLoadIdentity();
        glMatrixMode(GL_PROJECTION);
        glPushMatrix();

        // On initialise la matrice de projection: 1 pixel = 1 unité virtuelle.
        GLint Cloture[4];
        glGetIntegerv(GL_VIEWPORT, Cloture);
        glLoadIdentity();
        gluOrtho2D(0.0, (GLdouble) Cloture[2], (GLdouble) Cloture[3], 0.0);

        // On trace le rectangle en pointillés.
        glEnable(GL_LINE_STIPPLE);
        glLineStipple(facteur, patron);

        // On choisit la couleur blanche pour que le XOR soit une inversion des
        // bits de la couleur déjà présente dans la mémoire de trame.
        glColor3f(1.0, 1.0, 1.0);

        // On active le mode XOR.
        glEnable(GL_COLOR_LOGIC_OP);
        glLogicOp(GL_XOR);

        // On trace le rectangle en un seul point.
        glBegin(GL_LINE_LOOP);
        {
            glVertex2i(point[0], point[1]);
            glVertex2i(point[0], point[1]);
            glVertex2i(point[0], point[1]);
            glVertex2i(point[0], point[1]);
        }
        glEnd();

        // On veut que le rectangle soit immédiatement visible.
        glFlush();
    }


    ////////////////////////////////////////////////////////////////////////
    ///
    /// @fn void mettreAJourRectangleElastique(const glm::ivec2&amp; pointAncrage, const glm::ivec2&amp; pointAvant, const glm::ivec2&amp; pointApres)
    ///
    /// Cette fonction met à jour la position du rectangle élastique en
    /// effaçant le rectangle précédent pour le remplacer par un nouveau.
    ///
    /// @param[in] pointAncrage : Point initial de localisation du rectangle.
    /// @param[in] pointAvant   : Autre coin du rectangle avant la mise à jour.
    /// @param[in] pointApres   : Autre coin du rectangle après la mise à jour.
    ///
    /// @return Aucune.
    ///
    ////////////////////////////////////////////////////////////////////////
    void mettreAJourRectangleElastique(
        const glm::ivec2&amp; pointAncrage,
        const glm::ivec2&amp; pointAvant,
        const glm::ivec2&amp; pointApres
        )
    {
        // On trace l&#39;ancien rectangle pour l&#39;effacer et restaurer la couleur qui
        // était là avant (grâce au XOR).
        glBegin(GL_LINE_LOOP);
        {
            glVertex2i(pointAncrage[0], pointAncrage[1]);
            glVertex2i(pointAncrage[0], pointAvant[1]);
            glVertex2i(pointAvant[0], pointAvant[1]);
            glVertex2i(pointAvant[0], pointAncrage[1]);
        }
        glEnd();

        // On trace le nouveau rectangle.
        glBegin(GL_LINE_LOOP);
        {
            glVertex2i(pointAncrage[0], pointAncrage[1]);
            glVertex2i(pointAncrage[0], pointApres[1]);
            glVertex2i(pointApres[0], pointApres[1]);
            glVertex2i(pointApres[0], pointAncrage[1]);
        }
        glEnd();

        // On s&#39;arrange pour que le nouveau rectangle soit immédiatement visible.
        glFlush();
    }


    ////////////////////////////////////////////////////////////////////////
    ///
    /// @fn void terminerRectangleElastique(const glm::ivec2&amp; pointAncrage, const glm::ivec2&amp; pointFinal)
    ///
    /// Cette fonction termine le mode de rendu du rectangle élastique en
    /// restaurant l&#39;état de la machine OpenGL à ce qu&#39;il était.
    ///
    /// @param[in] pointAncrage : Point initial de localisation du rectangle.
    /// @param[in] pointFinal   : Point final de localisation du rectangle.
    ///
    /// @return Aucune.
    ///
    ////////////////////////////////////////////////////////////////////////
    void terminerRectangleElastique(
        const glm::ivec2&amp; pointAncrage,
        const glm::ivec2&amp; pointFinal
        )
    {
        // On trace l&#39;ancien rectangle pour l&#39;effacer et restaurer la couleur qui
        // était là avant (grâce au XOR).
        glBegin(GL_LINE_LOOP);
        {
            glVertex2i(pointAncrage[0], pointAncrage[1]);
            glVertex2i(pointAncrage[0], pointFinal[1]);
            glVertex2i(pointFinal[0], pointFinal[1]);
            glVertex2i(pointFinal[0], pointAncrage[1]);
        }
        glEnd();

        // On rétablit les attributs initiaux.
        glPopAttrib();

        // On rétablit la transformation initiale.
        glMatrixMode(GL_PROJECTION);
        glPopMatrix();
        glMatrixMode(GL_MODELVIEW);
        glPopMatrix();

        // On s&#39;arrange pour que le nouveau rectangle soit immédiatement visible.
        glFlush();

        // On se remet à dessiner dans le tampon arrière.
        glDrawBuffer(GL_BACK);
    }


    ////////////////////////////////////////////////////////////////////////
    ///
    /// @fn void afficherRectangle(const glm::dvec3&amp; point1, const glm::dvec3&amp; point2, const glm::dvec3&amp; point3, const glm::dvec3&amp; point4, int divisionS, int divisionT)
    ///
    /// Cette fonction affiche un rectangle subdivisé en grille d&#39;un certain
    /// nombre de points.
    ///
    /// @param[in] point1    : Premier point du rectangle.
    /// @param[in] point2    : Second point du rectangle.
    /// @param[in] point3    : Troisième point du rectangle.
    /// @param[in] point4    : Quatrième point du rectangle.
    /// @param[in] divisionS : Nombre de divisions dans une dimension.
    /// @param[in] divisionT : Nombre de divisions dans l&#39;autre dimension.
    ///
    /// @return Aucune.
    ///
    ////////////////////////////////////////////////////////////////////////
    void afficherRectangle(
        const glm::dvec3&amp; point1, const glm::dvec3&amp; point2,
        const glm::dvec3&amp; point3, const glm::dvec3&amp; point4,
        int divisionS, int divisionT
        )
    {
        const glm::dvec3 dirS1{ point2 - point1 };
        const glm::dvec3 dirS2{ point3 - point4 };

        glm::dvec3 ancienInter1{ point1 };
        glm::dvec3 ancienDirT{ point4 - point1 };
        for (int i = 1; i &lt; divisionS; ++i) {
            const double factorS{ i / (double) (divisionS - 1) };
            const glm::dvec3 inter1{ point1 + dirS1 * factorS };
            const glm::dvec3 inter2{ point4 + dirS2 * factorS };
            const glm::dvec3 dirT{ inter2 - inter1 };

            glBegin(GL_QUAD_STRIP);
            for (int j = 0; j &lt; divisionT; ++j) {
                const double factorT{ j / (double) (divisionT - 1) };
                const glm::dvec3 vertex1{ ancienInter1 + ancienDirT * factorT };
                const glm::dvec3 vertex2{ inter1 + dirT * factorT };

                glVertex3d(vertex1[0], vertex1[1], vertex1[2]);
                glVertex3d(vertex2[0], vertex2[1], vertex2[2]);
            }
            glEnd();

            ancienInter1 = inter1;
            ancienDirT = dirT;
        }
    }


    ////////////////////////////////////////////////////////////////////////
    ///
    /// @fn void afficherRectangle(const glm::dvec3&amp; point1, const glm::dvec3&amp; point2, const glm::dvec3&amp; point3, const glm::dvec3&amp; point4, double deltaS, double deltaT)
    ///
    /// Cette fonction affiche un rectangle subdivisé en grille d&#39;une certaine
    /// distance maximal entre chacun des points successifs.
    ///
    /// @param[in] point1 : Premier point du rectangle.
    /// @param[in] point2 : Second point du rectangle.
    /// @param[in] point3 : Troisième point du rectangle.
    /// @param[in] point4 : Quatrième point du rectangle.
    /// @param[in] deltaS : Distance maximale dans une dimension.
    /// @param[in] deltaT : Distance maximale dans l&#39;autre dimension.
    ///
    /// @return Aucune.
    ///
    ////////////////////////////////////////////////////////////////////////
    void afficherRectangleIntervalle(
        const glm::dvec3&amp; point1, const glm::dvec3&amp; point2,
        const glm::dvec3&amp; point3, const glm::dvec3&amp; point4,
        double deltaS, double deltaT
        )
    {
        int nS1{ (int) (0.5f + glm::length(point2 - point1) / deltaS) };
        int nS2{ (int) (0.5f + glm::length(point3 - point4) / deltaS) };
        int nT1{ (int) (0.5f + glm::length(point4 - point1) / deltaT) };
        int nT2{ (int) (0.5f + glm::length(point2 - point3) / deltaT) };

        int S{ nS1 &gt; nS2 ? nS1 : nS2 };
        if (S &lt; 2)
            S = 2;
        int T{ nT1 &gt; nT2 ? nT1 : nT2 };
        if (T &lt; 2)
            T = 2;

        afficherRectangle(point1, point2, point3, point4, S, T);
    }


    ////////////////////////////////////////////////////////////////////////
    ///
    /// @fn std::string obtenirMessageErreur(GLenum codeErreur, int drapeau)
    ///
    /// Cette fonction retourne une chaîne détaillant l&#39;erreur identifiée par
    /// le code d&#39;erreur passé en paramètre.  La chaîne retournée contient
    /// d&#39;abord le nom de la constante identifiant le code d&#39;erreur, suivi
    /// du message de la fonction gluErrorString(), et une explication
    /// provenant du &quot;man page&quot; de glGetError().
    ///
    /// @param[in] codeErreur : Code d&#39;erreur.
    /// @param[in] drapeau    : Information désirée dans le message d&#39;erreur.
    ///
    /// @return Chaîne contenant le message d&#39;erreur.
    ///
    ////////////////////////////////////////////////////////////////////////
    std::string obtenirMessageErreur(
        GLenum codeErreur, int drapeau //= AFFICHE_ERREUR_TOUT
        )
    {
        std::string chaineCode;
        std::string message;

        // Il sera possible d&#39;avoir un &quot;map&quot; au lieu de ce switch, qui n&#39;est pas
        // très performant pour les cas où on ne veut pas le message par exemple.
        switch (codeErreur) {
        case GL_NO_ERROR:
            chaineCode = &quot;GL_NO_ERROR&quot;;
            message = &quot;No error has been recorded.  The value of this &quot;
                &quot;symbolic constant is guaranteed to be 0.&quot;;
            break;

        case GL_INVALID_ENUM:
            chaineCode = &quot;GL_INVALID_ENUM&quot;;
            message = &quot;An unacceptable value is specified for an enumerated &quot;
                &quot;argument.  The offending command is ignored, and has &quot;
                &quot;no other side effect than to set the error flag.&quot;;
            break;

        case GL_INVALID_VALUE:
            chaineCode = &quot;GL_INVALID_VALUE&quot;;
            message = &quot;A numeric argument is out of range.  The offending &quot;
                &quot;command is ignored, and has no other side effect than &quot;
                &quot;to set the error flag.&quot;;
            break;

        case GL_INVALID_OPERATION:
            chaineCode = &quot;GL_INVALID_OPERATION&quot;;
            message = &quot;The specified operation is not allowed in the current &quot;
                &quot;state.  The offending command is ignored, and has no &quot;
                &quot;other side effect than to set the error flag.&quot;;
            break;

        case GL_STACK_OVERFLOW:
            chaineCode = &quot;GL_STACK_OVERFLOW&quot;;
            message = &quot;This command would cause a stack overflow.  The &quot;
                &quot;offending command is ignored, and has no other side &quot;
                &quot;effect than to set the error flag.&quot;;
            break;

        case GL_STACK_UNDERFLOW:
            chaineCode = &quot;GL_STACK_UNDERFLOW&quot;;
            message = &quot;This command would cause a stack underflow.  The &quot;
                &quot;offending command is ignored, and has no other side &quot;
                &quot;effect than to set the error flag.&quot;;
            break;

        case GL_OUT_OF_MEMORY:
            chaineCode = &quot;GL_OUT_OF_MEMORY&quot;;
            message = &quot;There is not enough memory left to execute the &quot;
                &quot;command.  The state of the GL is undefined, except &quot;
                &quot;for the state of the error flags, after this error is &quot;
                &quot;recorded.&quot;;
            break;

        default:
            chaineCode = &quot;GL_????????&quot;;
            message = &quot;Code d&#39;erreur non identifié.&quot;;
            break;
        };

        // Concatenation des messages
        bool aPrecedent{ false };
        std::string retour;

        if (drapeau &amp; AFFICHE_ERREUR_CODE) {
            retour = chaineCode;
            aPrecedent = true;
        }

        if (drapeau &amp; AFFICHE_ERREUR_GLUERRORSTRING) {
            if (aPrecedent)
                retour += &quot; , &quot;;
            retour += reinterpret_cast&lt;const char*&gt; (
                gluErrorString(codeErreur)
                );
            aPrecedent = true;
        }

        if (drapeau &amp; AFFICHE_ERREUR_DESCRIPTION) {
            if (aPrecedent)
                retour += &quot; , &quot;;
            retour += message;
        }

        return retour;
    }


    ////////////////////////////////////////////////////////////////////////
    ///
    /// @fn void verifierErreurOpenGL(int drapeau)
    ///
    /// Cette fonction vérifie s&#39;il y a une erreur OpenGL, et si c&#39;est le cas
    /// affiche un message d&#39;erreur correspondant à l&#39;erreur.
    ///
    /// @param[in] drapeau : Information désirée dans le message d&#39;erreur.
    ///
    /// @return Aucune.
    ///
    ////////////////////////////////////////////////////////////////////////
    void verifierErreurOpenGL(
        int drapeau //= AFFICHE_ERREUR_TOUT
        )
    {
        GLenum codeErreur{ glGetError() };

        if (codeErreur || (drapeau &amp; AFFICHE_ERREUR_AUCUNE))
            std::cerr &lt;&lt; obtenirMessageErreur(codeErreur, drapeau) &lt;&lt; std::endl;
    }


    ///////////////////////////////////////////////////////////////////////////
    ///
    /// @fn bool glLoadTexture(const std::string&amp; nomFichier, unsigned int&amp; idTexture,
    ///                        bool genererTexture)
    ///
    /// Cette fonction crée une texture OpenGL à partir d&#39;une image contenu
    /// dans un fichier.  FreeImage est utilisée pour lire l&#39;image, donc tous
    /// les formats reconnues par cette librairie devraient être supportés.
    ///
    /// @param[in]  nomFichier     : Le nom du fichier image à charger.
    /// @param[out] idTexture      : L&#39;identificateur de la texture créée.
    /// @param[in]  genererTexture : Doit-on demander à OpenGL de générer un numéro
    ///                                     de texture au préalable?
    ///
    /// @return Vrai si le chargement a réussi, faux autrement.
    ///
    ///////////////////////////////////////////////////////////////////////////
    bool glLoadTexture(const std::string&amp; nomFichier, unsigned int&amp; idTexture, bool genererTexture)
    {
        FIBITMAP* dib;
        FIBITMAP* dib32;
        glLoadImage(nomFichier, dib, dib32);

        unsigned int pitch{ FreeImage_GetPitch(dib32) };

        glCreateTexture(
            FreeImage_GetBits(dib32),
            FreeImage_GetWidth(dib32),
            FreeImage_GetHeight(dib32),
            FreeImage_GetBPP(dib32),
            FreeImage_GetPitch(dib32),
            idTexture,
            genererTexture
            );

        FreeImage_Unload(dib32);
        FreeImage_Unload(dib);

        return true;
    }

    ///////////////////////////////////////////////////////////////////////////
    ///
    /// @fn bool glLoadImage(const std::string&amp; nomFichier, FIBITMAP*&amp; dib, FIBITMAP*&amp; dib32)
    ///
    /// Cette fonction extrait les données d&#39;une image.  
    /// FreeImage est utilisée pour lire l&#39;image, donc tous
    /// les formats reconnues par cette librairie devraient être supportés.
    ///
    /// @param[in]  nomFichier     : Le nom du fichier image à charger.
    /// @param[out] dib            : Les donnnées de l&#39;image.
    /// @param[in]  dib32          : Les données de l&#39;image sous un format 32 bit
    ///
    /// @return Vrai si le chargement a réussi, faux autrement.
    ///
    ///////////////////////////////////////////////////////////////////////////
    bool glLoadImage(const std::string&amp; nomFichier, FIBITMAP*&amp; dib, FIBITMAP*&amp; dib32)
    {
        // Ce code de lecture générique d&#39;un fichier provient de la
        // documentation de FreeImage
        FREE_IMAGE_FORMAT format{ FIF_UNKNOWN };
        // check the file signature and deduce its format
        // (the second argument is currently not used by FreeImage)
        format = FreeImage_GetFileType(nomFichier.c_str(), 0);
        if (format == FIF_UNKNOWN) {
            // no signature ?
            // try to guess the file format from the file extension
            format = FreeImage_GetFIFFromFilename(nomFichier.c_str());
        }
        // check that the plugin has reading capabilities ...
        if ((format == FIF_UNKNOWN) || !FreeImage_FIFSupportsReading(format)) {
            utilitaire::afficherErreur(
                std::string{ &quot;Format du fichier image \&quot;&quot; } +
                std::string{ nomFichier.c_str() } +std::string{ &quot;\&quot; non supporté" }
            );
            return false;
        }
        // ok, let&#39;s load the file
        dib = FreeImage_Load(format, nomFichier.c_str(), 0);

        if (dib == 0) {
            utilitaire::afficherErreur(
                std::string{ &quot;Erreur à la lecture du fichier \&quot;&quot; } +
                std::string{ nomFichier.c_str() } +std::string{ &quot;\&quot;&quot; }
            );
            return false;
        }

        dib32 = FreeImage_ConvertTo32Bits(dib);
        if (dib32 == 0) {
            utilitaire::afficherErreur(
                std::string{ &quot;Incapable de convertir le fichier \&quot;&quot; } +
                std::string{ nomFichier.c_str() } +std::string{ &quot;\&quot; en 32 bpp.&quot; }
            );
            FreeImage_Unload(dib);
            return false;
        }

        return true;
    }


    ///////////////////////////////////////////////////////////////////////////
    ///
    /// @fn void glCreateTexture(unsigned char* data, int x, int y, int bpp, int pitch,
    ///                          unsigned int&amp; ID, bool genererTexture)
    ///
    /// Cette fonction crée une texture à partir des pixels en mémoire.
    ///
    /// @param[in]  data           : Le tableau des valeurs des pixels.
    /// @param[in]  x              : La largeur de l&#39;image.
    /// @param[in]  y              : La hauteur de l&#39;image.
    /// @param[in]  bpp            : Le nombre de bits par pixels.
    /// @param[in]  pitch          : La largeur en mémoire d&#39;une rangée de l&#39;image.
    /// @param[out] ID             : L&#39;identificateur de la texture créée.
    /// @param[in]  genererTexture : Doit-on demander à OpenGL de générer un numéro
    ///                                     de texture au préalable?
    ///
    /// @return Aucune.
    ///
    ///////////////////////////////////////////////////////////////////////////
    void glCreateTexture(
        unsigned char* data, int x, int y, int bpp, int pitch, unsigned int&amp; ID, bool genererTexture
        )
    {
        if (genererTexture) {
            glGenTextures(1, &amp;ID);
        }
        glBindTexture(GL_TEXTURE_2D, ID);

        // Le pitch est ignoré pour le moment, car on le suppose toujours égal à
      // la largeur, mais il pourrait être utilisé pour produire une
        // implantation plus robuste.
        if (pitch != x*bpp / 8) {
            utilitaire::afficherErreur(
                &quot;L&#39;implantation ne supporte pas un \&quot;pitch\&quot; différent de la largeur.&quot;
                );
            return;
        }

        // Tel que spécifié dans la documentation de FreeImage (voir Pixel Access 
        // Functions, page 29 du PDF FreeImage 3.9.0 documentation), la 
        // disposition des composantes des couleurs est dépendante de 
        // l&#39;architecture.  Sur little endian, le format BGR (plutôt que RGB) est 
        // utilisé.  On utilise donc l&#39;extension GL_EXT_bgra (on pourrait vérifie 
        // à l&#39;exécution que l&#39;extension est présente)
        if (bpp == 24)
            gluBuild2DMipmaps(GL_TEXTURE_2D, 3, x, y, GL_BGR_EXT, GL_UNSIGNED_BYTE, data);
        else if (bpp == 32)
            gluBuild2DMipmaps(GL_TEXTURE_2D, 4, x, y, GL_BGRA_EXT, GL_UNSIGNED_BYTE, data);
        else
            utilitaire::afficherErreur(
            &quot;Incapable de lire une image qui n&#39;a pas 24 ou 32 bits par pixels.&quot;
            );

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    }


} // Fin de l&#39;espace de nom aidegl.


///////////////////////////////////////////////////////////////////////////
/// @}
///////////////////////////////////////////////////////////////////////////
</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    }</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00117"></a><span class="lineno"><a class="line" href="namespaceaidegl.html#a0cb31f11533480a059574970f5fcff6b">  117</a></span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="namespaceaidegl.html#a0cb31f11533480a059574970f5fcff6b">detruireContexteGL</a>(HWND hWnd, HDC hDC, HGLRC hRC)</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    {</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <span class="keywordtype">bool</span> succes = <span class="keyword">true</span>;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        <span class="keywordflow">if</span> (!::wglMakeCurrent(0, 0))</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;            succes = <span class="keyword">false</span>;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        <span class="keywordflow">if</span> (!::wglDeleteContext(hRC))</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            succes = <span class="keyword">false</span>;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        <span class="keywordflow">if</span> (::ReleaseDC(hWnd, hDC) == 0)</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;            succes = <span class="keyword">false</span>;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        <span class="keywordflow">return</span> succes;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    }</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno"><a class="line" href="namespaceaidegl.html#a0680ab3e3bddc4c7b123c46117e31094">  149</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="namespaceaidegl.html#a0680ab3e3bddc4c7b123c46117e31094">initialiserRectangleElastique</a>(</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        <span class="keyword">const</span> glm::ivec2&amp; point,</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>   patron, <span class="comment">//= 0x3333</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        <span class="keywordtype">int</span>              facteur <span class="comment">//= 1</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;        )</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    {</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;        <span class="comment">// On sauvegarde les attributs de traçage.</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        glPushAttrib(GL_LINE_BIT |</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;            GL_CURRENT_BIT |</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;            GL_COLOR_BUFFER_BIT |</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;            GL_DEPTH_BUFFER_BIT);</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;        <span class="comment">// On dessine uniquement dans ce qui est déjà à l&#39;écran.</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;        glDrawBuffer(GL_FRONT);</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        <span class="comment">// On désactive le test de profondeur et les textures.</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;        glDisable(GL_DEPTH_TEST);</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;        glDisable(GL_TEXTURE_2D);</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        <span class="comment">// On sauvegarde les matrices de transformation.</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        glMatrixMode(GL_MODELVIEW);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        glPushMatrix();</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        glLoadIdentity();</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        glMatrixMode(GL_PROJECTION);</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        glPushMatrix();</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <span class="comment">// On initialise la matrice de projection: 1 pixel = 1 unité virtuelle.</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        GLint Cloture[4];</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        glGetIntegerv(GL_VIEWPORT, Cloture);</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        glLoadIdentity();</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        gluOrtho2D(0.0, (GLdouble) Cloture[2], (GLdouble) Cloture[3], 0.0);</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        <span class="comment">// On trace le rectangle en pointillés.</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        glEnable(GL_LINE_STIPPLE);</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        glLineStipple(facteur, patron);</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="comment">// On choisit la couleur blanche pour que le XOR soit une inversion des</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        <span class="comment">// bits de la couleur déjà présente dans la mémoire de trame.</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        glColor3f(1.0, 1.0, 1.0);</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        <span class="comment">// On active le mode XOR.</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        glEnable(GL_COLOR_LOGIC_OP);</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        glLogicOp(GL_XOR);</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        <span class="comment">// On trace le rectangle en un seul point.</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        glBegin(GL_LINE_LOOP);</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        {</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;            glVertex2i(point[0], point[1]);</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            glVertex2i(point[0], point[1]);</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;            glVertex2i(point[0], point[1]);</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            glVertex2i(point[0], point[1]);</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        }</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        glEnd();</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        <span class="comment">// On veut que le rectangle soit immédiatement visible.</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        glFlush();</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    }</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00222"></a><span class="lineno"><a class="line" href="namespaceaidegl.html#a900742dca102d07d9ae7efd8a5e0cce8">  222</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="namespaceaidegl.html#a900742dca102d07d9ae7efd8a5e0cce8">mettreAJourRectangleElastique</a>(</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        <span class="keyword">const</span> glm::ivec2&amp; pointAncrage,</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        <span class="keyword">const</span> glm::ivec2&amp; pointAvant,</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        <span class="keyword">const</span> glm::ivec2&amp; pointApres</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        )</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    {</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        <span class="comment">// On trace l&#39;ancien rectangle pour l&#39;effacer et restaurer la couleur qui</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        <span class="comment">// était là avant (grâce au XOR).</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        glBegin(GL_LINE_LOOP);</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        {</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            glVertex2i(pointAncrage[0], pointAncrage[1]);</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;            glVertex2i(pointAncrage[0], pointAvant[1]);</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            glVertex2i(pointAvant[0], pointAvant[1]);</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;            glVertex2i(pointAvant[0], pointAncrage[1]);</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        }</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        glEnd();</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        <span class="comment">// On trace le nouveau rectangle.</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        glBegin(GL_LINE_LOOP);</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        {</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;            glVertex2i(pointAncrage[0], pointAncrage[1]);</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            glVertex2i(pointAncrage[0], pointApres[1]);</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            glVertex2i(pointApres[0], pointApres[1]);</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;            glVertex2i(pointApres[0], pointAncrage[1]);</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        }</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;        glEnd();</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        <span class="comment">// On s&#39;arrange pour que le nouveau rectangle soit immédiatement visible.</span></div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        glFlush();</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    }</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;</div><div class="line"><a name="l00267"></a><span class="lineno"><a class="line" href="namespaceaidegl.html#a023f37325ede13a1f60243382cc11b12">  267</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="namespaceaidegl.html#a023f37325ede13a1f60243382cc11b12">terminerRectangleElastique</a>(</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;        <span class="keyword">const</span> glm::ivec2&amp; pointAncrage,</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        <span class="keyword">const</span> glm::ivec2&amp; pointFinal</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        )</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    {</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        <span class="comment">// On trace l&#39;ancien rectangle pour l&#39;effacer et restaurer la couleur qui</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        <span class="comment">// était là avant (grâce au XOR).</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;        glBegin(GL_LINE_LOOP);</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;        {</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;            glVertex2i(pointAncrage[0], pointAncrage[1]);</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;            glVertex2i(pointAncrage[0], pointFinal[1]);</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;            glVertex2i(pointFinal[0], pointFinal[1]);</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;            glVertex2i(pointFinal[0], pointAncrage[1]);</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        }</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        glEnd();</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        <span class="comment">// On rétablit les attributs initiaux.</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;        glPopAttrib();</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;        <span class="comment">// On rétablit la transformation initiale.</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;        glMatrixMode(GL_PROJECTION);</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        glPopMatrix();</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        glMatrixMode(GL_MODELVIEW);</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        glPopMatrix();</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <span class="comment">// On s&#39;arrange pour que le nouveau rectangle soit immédiatement visible.</span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        glFlush();</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        <span class="comment">// On se remet à dessiner dans le tampon arrière.</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        glDrawBuffer(GL_BACK);</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    }</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno"><a class="line" href="namespaceaidegl.html#ab9d35d5387a501181fe379dd596bd25d">  317</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="namespaceaidegl.html#ab9d35d5387a501181fe379dd596bd25d">afficherRectangle</a>(</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;        <span class="keyword">const</span> glm::dvec3&amp; point1, <span class="keyword">const</span> glm::dvec3&amp; point2,</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        <span class="keyword">const</span> glm::dvec3&amp; point3, <span class="keyword">const</span> glm::dvec3&amp; point4,</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        <span class="keywordtype">int</span> divisionS, <span class="keywordtype">int</span> divisionT</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        )</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    {</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        <span class="keyword">const</span> glm::dvec3 dirS1{ point2 - point1 };</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        <span class="keyword">const</span> glm::dvec3 dirS2{ point3 - point4 };</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        glm::dvec3 ancienInter1{ point1 };</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        glm::dvec3 ancienDirT{ point4 - point1 };</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; divisionS; ++i) {</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">double</span> factorS{ i / (double) (divisionS - 1) };</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;            <span class="keyword">const</span> glm::dvec3 inter1{ point1 + dirS1 * factorS };</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;            <span class="keyword">const</span> glm::dvec3 inter2{ point4 + dirS2 * factorS };</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;            <span class="keyword">const</span> glm::dvec3 dirT{ inter2 - inter1 };</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;            glBegin(GL_QUAD_STRIP);</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; divisionT; ++j) {</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">double</span> factorT{ j / (double) (divisionT - 1) };</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                <span class="keyword">const</span> glm::dvec3 vertex1{ ancienInter1 + ancienDirT * factorT };</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                <span class="keyword">const</span> glm::dvec3 vertex2{ inter1 + dirT * factorT };</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                glVertex3d(vertex1[0], vertex1[1], vertex1[2]);</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                glVertex3d(vertex2[0], vertex2[1], vertex2[2]);</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;            }</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;            glEnd();</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;            ancienInter1 = inter1;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;            ancienDirT = dirT;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        }</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    }</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;</div><div class="line"><a name="l00368"></a><span class="lineno"><a class="line" href="namespaceaidegl.html#a6775d81c7b7b695dcfb3f3d50cc253a5">  368</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="namespaceaidegl.html#a6775d81c7b7b695dcfb3f3d50cc253a5">afficherRectangleIntervalle</a>(</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;        <span class="keyword">const</span> glm::dvec3&amp; point1, <span class="keyword">const</span> glm::dvec3&amp; point2,</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;        <span class="keyword">const</span> glm::dvec3&amp; point3, <span class="keyword">const</span> glm::dvec3&amp; point4,</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;        <span class="keywordtype">double</span> deltaS, <span class="keywordtype">double</span> deltaT</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        )</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    {</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        <span class="keywordtype">int</span> nS1{ (int) (0.5f + glm::length(point2 - point1) / deltaS) };</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        <span class="keywordtype">int</span> nS2{ (int) (0.5f + glm::length(point3 - point4) / deltaS) };</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        <span class="keywordtype">int</span> nT1{ (int) (0.5f + glm::length(point4 - point1) / deltaT) };</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        <span class="keywordtype">int</span> nT2{ (int) (0.5f + glm::length(point2 - point3) / deltaT) };</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        <span class="keywordtype">int</span> S{ nS1 &gt; nS2 ? nS1 : nS2 };</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        <span class="keywordflow">if</span> (S &lt; 2)</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;            S = 2;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        <span class="keywordtype">int</span> T{ nT1 &gt; nT2 ? nT1 : nT2 };</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        <span class="keywordflow">if</span> (T &lt; 2)</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;            T = 2;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        <a class="code" href="namespaceaidegl.html#ab9d35d5387a501181fe379dd596bd25d">afficherRectangle</a>(point1, point2, point3, point4, S, T);</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    }</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;</div><div class="line"><a name="l00406"></a><span class="lineno"><a class="line" href="namespaceaidegl.html#a19ef7b4b71b7a1568393cfc78be46a91">  406</a></span>&#160;    std::string <a class="code" href="namespaceaidegl.html#a19ef7b4b71b7a1568393cfc78be46a91">obtenirMessageErreur</a>(</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        GLenum codeErreur, <span class="keywordtype">int</span> drapeau <span class="comment">//= AFFICHE_ERREUR_TOUT</span></div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;        )</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    {</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;        std::string chaineCode;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        std::string message;</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        <span class="comment">// Il sera possible d&#39;avoir un &quot;map&quot; au lieu de ce switch, qui n&#39;est pas</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        <span class="comment">// très performant pour les cas où on ne veut pas le message par exemple.</span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        <span class="keywordflow">switch</span> (codeErreur) {</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        <span class="keywordflow">case</span> GL_NO_ERROR:</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;            chaineCode = <span class="stringliteral">&quot;GL_NO_ERROR&quot;</span>;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;            message = <span class="stringliteral">&quot;No error has been recorded.  The value of this &quot;</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;                <span class="stringliteral">&quot;symbolic constant is guaranteed to be 0.&quot;</span>;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        <span class="keywordflow">case</span> GL_INVALID_ENUM:</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;            chaineCode = <span class="stringliteral">&quot;GL_INVALID_ENUM&quot;</span>;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;            message = <span class="stringliteral">&quot;An unacceptable value is specified for an enumerated &quot;</span></div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;                <span class="stringliteral">&quot;argument.  The offending command is ignored, and has &quot;</span></div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;                <span class="stringliteral">&quot;no other side effect than to set the error flag.&quot;</span>;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;        <span class="keywordflow">case</span> GL_INVALID_VALUE:</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;            chaineCode = <span class="stringliteral">&quot;GL_INVALID_VALUE&quot;</span>;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;            message = <span class="stringliteral">&quot;A numeric argument is out of range.  The offending &quot;</span></div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                <span class="stringliteral">&quot;command is ignored, and has no other side effect than &quot;</span></div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;                <span class="stringliteral">&quot;to set the error flag.&quot;</span>;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;        <span class="keywordflow">case</span> GL_INVALID_OPERATION:</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;            chaineCode = <span class="stringliteral">&quot;GL_INVALID_OPERATION&quot;</span>;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;            message = <span class="stringliteral">&quot;The specified operation is not allowed in the current &quot;</span></div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                <span class="stringliteral">&quot;state.  The offending command is ignored, and has no &quot;</span></div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;                <span class="stringliteral">&quot;other side effect than to set the error flag.&quot;</span>;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        <span class="keywordflow">case</span> GL_STACK_OVERFLOW:</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;            chaineCode = <span class="stringliteral">&quot;GL_STACK_OVERFLOW&quot;</span>;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            message = <span class="stringliteral">&quot;This command would cause a stack overflow.  The &quot;</span></div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                <span class="stringliteral">&quot;offending command is ignored, and has no other side &quot;</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;                <span class="stringliteral">&quot;effect than to set the error flag.&quot;</span>;</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        <span class="keywordflow">case</span> GL_STACK_UNDERFLOW:</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;            chaineCode = <span class="stringliteral">&quot;GL_STACK_UNDERFLOW&quot;</span>;</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;            message = <span class="stringliteral">&quot;This command would cause a stack underflow.  The &quot;</span></div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                <span class="stringliteral">&quot;offending command is ignored, and has no other side &quot;</span></div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                <span class="stringliteral">&quot;effect than to set the error flag.&quot;</span>;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;        <span class="keywordflow">case</span> GL_OUT_OF_MEMORY:</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;            chaineCode = <span class="stringliteral">&quot;GL_OUT_OF_MEMORY&quot;</span>;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;            message = <span class="stringliteral">&quot;There is not enough memory left to execute the &quot;</span></div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                <span class="stringliteral">&quot;command.  The state of the GL is undefined, except &quot;</span></div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;                <span class="stringliteral">&quot;for the state of the error flags, after this error is &quot;</span></div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                <span class="stringliteral">&quot;recorded.&quot;</span>;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;            chaineCode = <span class="stringliteral">&quot;GL_????????&quot;</span>;</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;            message = <span class="stringliteral">&quot;Code d&#39;erreur non identifié.&quot;</span>;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;        };</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;        <span class="comment">// Concatenation des messages</span></div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        <span class="keywordtype">bool</span> aPrecedent{ <span class="keyword">false</span> };</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;        std::string retour;</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;        <span class="keywordflow">if</span> (drapeau &amp; AFFICHE_ERREUR_CODE) {</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;            retour = chaineCode;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;            aPrecedent = <span class="keyword">true</span>;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        }</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        <span class="keywordflow">if</span> (drapeau &amp; AFFICHE_ERREUR_GLUERRORSTRING) {</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;            <span class="keywordflow">if</span> (aPrecedent)</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;                retour += <span class="stringliteral">&quot; , &quot;</span>;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;            retour += <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span> (</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;                gluErrorString(codeErreur)</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;                );</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;            aPrecedent = <span class="keyword">true</span>;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;        }</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;        <span class="keywordflow">if</span> (drapeau &amp; AFFICHE_ERREUR_DESCRIPTION) {</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;            <span class="keywordflow">if</span> (aPrecedent)</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;                retour += <span class="stringliteral">&quot; , &quot;</span>;</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;            retour += message;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;        }</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        <span class="keywordflow">return</span> retour;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    }</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;</div><div class="line"><a name="l00511"></a><span class="lineno"><a class="line" href="namespaceaidegl.html#a923ac6c4f17f9d93b072c786e0f86d41">  511</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="namespaceaidegl.html#a923ac6c4f17f9d93b072c786e0f86d41">verifierErreurOpenGL</a>(</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;        <span class="keywordtype">int</span> drapeau <span class="comment">//= AFFICHE_ERREUR_TOUT</span></div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        )</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    {</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        GLenum codeErreur{ glGetError() };</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;        <span class="keywordflow">if</span> (codeErreur || (drapeau &amp; AFFICHE_ERREUR_AUCUNE))</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;            std::cerr &lt;&lt; <a class="code" href="namespaceaidegl.html#a19ef7b4b71b7a1568393cfc78be46a91">obtenirMessageErreur</a>(codeErreur, drapeau) &lt;&lt; std::endl;</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    }</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;</div><div class="line"><a name="l00539"></a><span class="lineno"><a class="line" href="namespaceaidegl.html#a6bba7d34e4998b9c94fe5971ecf535c0">  539</a></span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="namespaceaidegl.html#a6bba7d34e4998b9c94fe5971ecf535c0">glLoadTexture</a>(<span class="keyword">const</span> std::string&amp; nomFichier, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; idTexture, <span class="keywordtype">bool</span> genererTexture)</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    {</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;        FIBITMAP* dib;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;        FIBITMAP* dib32;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;        <a class="code" href="namespaceaidegl.html#a9c0697d5fd715999addf407852d93e4b">glLoadImage</a>(nomFichier, dib, dib32);</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pitch{ FreeImage_GetPitch(dib32) };</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;        <a class="code" href="namespaceaidegl.html#af6f5a219dd414d647d8e4d92b6c30fd5">glCreateTexture</a>(</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;            FreeImage_GetBits(dib32),</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;            FreeImage_GetWidth(dib32),</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;            FreeImage_GetHeight(dib32),</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;            FreeImage_GetBPP(dib32),</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;            FreeImage_GetPitch(dib32),</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;            idTexture,</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;            genererTexture</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;            );</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;        FreeImage_Unload(dib32);</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;        FreeImage_Unload(dib);</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    }</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div><div class="line"><a name="l00578"></a><span class="lineno"><a class="line" href="namespaceaidegl.html#a9c0697d5fd715999addf407852d93e4b">  578</a></span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="namespaceaidegl.html#a9c0697d5fd715999addf407852d93e4b">glLoadImage</a>(<span class="keyword">const</span> std::string&amp; nomFichier, FIBITMAP*&amp; dib, FIBITMAP*&amp; dib32)</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;    {</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;        <span class="comment">// Ce code de lecture générique d&#39;un fichier provient de la</span></div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;        <span class="comment">// documentation de FreeImage</span></div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;        FREE_IMAGE_FORMAT format{ FIF_UNKNOWN };</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;        <span class="comment">// check the file signature and deduce its format</span></div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;        <span class="comment">// (the second argument is currently not used by FreeImage)</span></div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;        format = FreeImage_GetFileType(nomFichier.c_str(), 0);</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;        <span class="keywordflow">if</span> (format == FIF_UNKNOWN) {</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;            <span class="comment">// no signature ?</span></div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;            <span class="comment">// try to guess the file format from the file extension</span></div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;            format = FreeImage_GetFIFFromFilename(nomFichier.c_str());</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;        }</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;        <span class="comment">// check that the plugin has reading capabilities ...</span></div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;        <span class="keywordflow">if</span> ((format == FIF_UNKNOWN) || !FreeImage_FIFSupportsReading(format)) {</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;            <a class="code" href="namespaceutilitaire.html#ac61bdab36cf1cbaa0d06fa8b1f35ab64">utilitaire::afficherErreur</a>(</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;                std::string{ <span class="stringliteral">&quot;Format du fichier image \&quot;&quot;</span> } +</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;                std::string{ nomFichier.c_str() } +std::string{ <span class="stringliteral">&quot;\&quot; non supporté  }
            );
            return false;
        }
        // ok, let&#39;s load the file
        dib = FreeImage_Load(format, nomFichier.c_str(), 0);

        if (dib == 0) {
            utilitaire::afficherErreur(
                std::string{ &quot;Erreur à la lecture du fichier \&quot;&quot; } +
                std::string{ nomFichier.c_str() } +std::string{ &quot;\&quot;&quot; }
            );
            return false;
        }

        dib32 = FreeImage_ConvertTo32Bits(dib);
        if (dib32 == 0) {
            utilitaire::afficherErreur(
                std::string{ &quot;Incapable de convertir le fichier \&quot;&quot; } +
                std::string{ nomFichier.c_str() } +std::string{ &quot;\&quot; en 32 bpp.&quot; }
            );
            FreeImage_Unload(dib);
            return false;
        }

        return true;
    }


    ///////////////////////////////////////////////////////////////////////////
    ///
    /// @fn void glCreateTexture(unsigned char* data, int x, int y, int bpp, int pitch,
    ///                          unsigned int&amp; ID, bool genererTexture)
    ///
    /// Cette fonction crée une texture à partir des pixels en mémoire.
    ///
    /// @param[in]  data           : Le tableau des valeurs des pixels.
    /// @param[in]  x              : La largeur de l&#39;image.
    /// @param[in]  y              : La hauteur de l&#39;image.
    /// @param[in]  bpp            : Le nombre de bits par pixels.
    /// @param[in]  pitch          : La largeur en mémoire d&#39;une rangée de l&#39;image.
    /// @param[out] ID             : L&#39;identificateur de la texture créée.
    /// @param[in]  genererTexture : Doit-on demander à OpenGL de générer un numéro
    ///                                     de texture au préalable?
    ///
    /// @return Aucune.
    ///
    ///////////////////////////////////////////////////////////////////////////
    void glCreateTexture(
        unsigned char* data, int x, int y, int bpp, int pitch, unsigned int&amp; ID, bool genererTexture
        )
    {
        if (genererTexture) {
            glGenTextures(1, &amp;ID);
        }
        glBindTexture(GL_TEXTURE_2D, ID);

        // Le pitch est ignoré pour le moment, car on le suppose toujours égal à
      // la largeur, mais il pourrait être utilisé pour produire une
        // implantation plus robuste.
        if (pitch != x*bpp / 8) {
            utilitaire::afficherErreur(
                &quot;L&#39;implantation ne supporte pas un \&quot;pitch\&quot; différent de la largeur.&quot;
                );
            return;
        }

        // Tel que spécifié dans la documentation de FreeImage (voir Pixel Access 
        // Functions, page 29 du PDF FreeImage 3.9.0 documentation), la 
        // disposition des composantes des couleurs est dépendante de 
        // l&#39;architecture.  Sur little endian, le format BGR (plutôt que RGB) est 
        // utilisé.  On utilise donc l&#39;extension GL_EXT_bgra (on pourrait vérifie 
        // à l&#39;exécution que l&#39;extension est présente)
        if (bpp == 24)
            gluBuild2DMipmaps(GL_TEXTURE_2D, 3, x, y, GL_BGR_EXT, GL_UNSIGNED_BYTE, data);
        else if (bpp == 32)
            gluBuild2DMipmaps(GL_TEXTURE_2D, 4, x, y, GL_BGRA_EXT, GL_UNSIGNED_BYTE, data);
        else
            utilitaire::afficherErreur(
            &quot;Incapable de lire une image qui n&#39;a pas 24 ou 32 bits par pixels.&quot;
            );

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    }


} // Fin de l&#39;espace de nom aidegl.


///////////////////////////////////////////////////////////////////////////
/// @}
///////////////////////////////////////////////////////////////////////////
&quot;</span> }</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;            );</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;        }</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;        <span class="comment">// ok, let&#39;s load the file</span></div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;        dib = FreeImage_Load(format, nomFichier.c_str(), 0);</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;        <span class="keywordflow">if</span> (dib == 0) {</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;            <a class="code" href="namespaceutilitaire.html#ac61bdab36cf1cbaa0d06fa8b1f35ab64">utilitaire::afficherErreur</a>(</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                std::string{ <span class="stringliteral">&quot;Erreur à la lecture du fichier \&quot;&quot;</span> } +</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                std::string{ nomFichier.c_str() } +std::string{ <span class="stringliteral">&quot;\&quot;&quot;</span> }</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;            );</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;        }</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;        dib32 = FreeImage_ConvertTo32Bits(dib);</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;        <span class="keywordflow">if</span> (dib32 == 0) {</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;            <a class="code" href="namespaceutilitaire.html#ac61bdab36cf1cbaa0d06fa8b1f35ab64">utilitaire::afficherErreur</a>(</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;                std::string{ <span class="stringliteral">&quot;Incapable de convertir le fichier \&quot;&quot;</span> } +</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;                std::string{ nomFichier.c_str() } +std::string{ <span class="stringliteral">&quot;\&quot; en 32 bpp.&quot;</span> }</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;            );</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;            FreeImage_Unload(dib);</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;        }</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    }</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;</div><div class="line"><a name="l00643"></a><span class="lineno"><a class="line" href="namespaceaidegl.html#af6f5a219dd414d647d8e4d92b6c30fd5">  643</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="namespaceaidegl.html#af6f5a219dd414d647d8e4d92b6c30fd5">glCreateTexture</a>(</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> <a class="code" href="group__inf2990.html#gab927965981178aa1fba979a37168db2a">y</a>, <span class="keywordtype">int</span> bpp, <span class="keywordtype">int</span> pitch, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; ID, <span class="keywordtype">bool</span> genererTexture</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;        )</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;    {</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;        <span class="keywordflow">if</span> (genererTexture) {</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;            glGenTextures(1, &amp;ID);</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;        }</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;        glBindTexture(GL_TEXTURE_2D, ID);</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;        <span class="comment">// Le pitch est ignoré pour le moment, car on le suppose toujours égal à       // la largeur, mais il pourrait être utilisé pour produire une
        // implantation plus robuste.
        if (pitch != x*bpp / 8) {
            utilitaire::afficherErreur(
                &quot;L&#39;implantation ne supporte pas un \&quot;pitch\&quot; différent de la largeur.&quot;
                );
            return;
        }

        // Tel que spécifié dans la documentation de FreeImage (voir Pixel Access 
        // Functions, page 29 du PDF FreeImage 3.9.0 documentation), la 
        // disposition des composantes des couleurs est dépendante de 
        // l&#39;architecture.  Sur little endian, le format BGR (plutôt que RGB) est 
        // utilisé.  On utilise donc l&#39;extension GL_EXT_bgra (on pourrait vérifie 
        // à l&#39;exécution que l&#39;extension est présente)
        if (bpp == 24)
            gluBuild2DMipmaps(GL_TEXTURE_2D, 3, x, y, GL_BGR_EXT, GL_UNSIGNED_BYTE, data);
        else if (bpp == 32)
            gluBuild2DMipmaps(GL_TEXTURE_2D, 4, x, y, GL_BGRA_EXT, GL_UNSIGNED_BYTE, data);
        else
            utilitaire::afficherErreur(
            &quot;Incapable de lire une image qui n&#39;a pas 24 ou 32 bits par pixels.&quot;
            );

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    }


} // Fin de l&#39;espace de nom aidegl.


///////////////////////////////////////////////////////////////////////////
/// @}
///////////////////////////////////////////////////////////////////////////
</span></div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;        <span class="comment">// la largeur, mais il pourrait être utilisé pour produire une</span></div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;        <span class="comment">// implantation plus robuste.</span></div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;        <span class="keywordflow">if</span> (pitch != x*bpp / 8) {</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;            <a class="code" href="namespaceutilitaire.html#ac61bdab36cf1cbaa0d06fa8b1f35ab64">utilitaire::afficherErreur</a>(</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                <span class="stringliteral">&quot;L&#39;implantation ne supporte pas un \&quot;pitch\&quot; différent de la largeur.&quot;</span></div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                );</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;            <span class="keywordflow">return</span>;</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;        }</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;        <span class="comment">// Tel que spécifié dans la documentation de FreeImage (voir Pixel Access </span></div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;        <span class="comment">// Functions, page 29 du PDF FreeImage 3.9.0 documentation), la </span></div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        <span class="comment">// disposition des composantes des couleurs est dépendante de </span></div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;        <span class="comment">// l&#39;architecture.  Sur little endian, le format BGR (plutôt que RGB) est </span></div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;        <span class="comment">// utilisé.  On utilise donc l&#39;extension GL_EXT_bgra (on pourrait vérifie </span></div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;        <span class="comment">// à l&#39;exécution que l&#39;extension est présente)</span></div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;        <span class="keywordflow">if</span> (bpp == 24)</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;            gluBuild2DMipmaps(GL_TEXTURE_2D, 3, x, y, GL_BGR_EXT, GL_UNSIGNED_BYTE, data);</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bpp == 32)</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;            gluBuild2DMipmaps(GL_TEXTURE_2D, 4, x, y, GL_BGRA_EXT, GL_UNSIGNED_BYTE, data);</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;            <a class="code" href="namespaceutilitaire.html#ac61bdab36cf1cbaa0d06fa8b1f35ab64">utilitaire::afficherErreur</a>(</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;            <span class="stringliteral">&quot;Incapable de lire une image qui n&#39;a pas 24 ou 32 bits par pixels.&quot;</span></div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;            );</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;    }</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;} <span class="comment">// Fin de l&#39;espace de nom aidegl.</span></div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;</div><div class="ttc" id="namespaceaidegl_html_a6775d81c7b7b695dcfb3f3d50cc253a5"><div class="ttname"><a href="namespaceaidegl.html#a6775d81c7b7b695dcfb3f3d50cc253a5">aidegl::afficherRectangleIntervalle</a></div><div class="ttdeci">void afficherRectangleIntervalle(const glm::dvec3 &amp;point1, const glm::dvec3 &amp;point2, const glm::dvec3 &amp;point3, const glm::dvec3 &amp;point4, double deltaS, double deltaT)</div><div class="ttdoc">Affiche un rectangle subdivisé d&amp;#39;un intervalle. </div><div class="ttdef"><b>Definition:</b> <a href="_aide_g_l_8cpp_source.html#l00368">AideGL.cpp:368</a></div></div>
<div class="ttc" id="namespaceaidegl_html_a9c0697d5fd715999addf407852d93e4b"><div class="ttname"><a href="namespaceaidegl.html#a9c0697d5fd715999addf407852d93e4b">aidegl::glLoadImage</a></div><div class="ttdeci">bool glLoadImage(const std::string &amp;nomFichier, FIBITMAP *&amp;dib, FIBITMAP *&amp;dib32)</div><div class="ttdoc">Charge les informations d&amp;#39;une image. </div><div class="ttdef"><b>Definition:</b> <a href="_aide_g_l_8cpp_source.html#l00578">AideGL.cpp:578</a></div></div>
<div class="ttc" id="namespaceaidegl_html_a900742dca102d07d9ae7efd8a5e0cce8"><div class="ttname"><a href="namespaceaidegl.html#a900742dca102d07d9ae7efd8a5e0cce8">aidegl::mettreAJourRectangleElastique</a></div><div class="ttdeci">void mettreAJourRectangleElastique(const glm::ivec2 &amp;pointAncrage, const glm::ivec2 &amp;pointAvant, const glm::ivec2 &amp;pointApres)</div><div class="ttdoc">Met à jour le rectangle élastique (suite à un déplacement). </div><div class="ttdef"><b>Definition:</b> <a href="_aide_g_l_8cpp_source.html#l00222">AideGL.cpp:222</a></div></div>
<div class="ttc" id="namespaceaidegl_html_ab9d35d5387a501181fe379dd596bd25d"><div class="ttname"><a href="namespaceaidegl.html#ab9d35d5387a501181fe379dd596bd25d">aidegl::afficherRectangle</a></div><div class="ttdeci">void afficherRectangle(const glm::dvec3 &amp;point1, const glm::dvec3 &amp;point2, const glm::dvec3 &amp;point3, const glm::dvec3 &amp;point4, int divisionS, int divisionT)</div><div class="ttdoc">Affiche un rectangle subdivisé par un nombre de subdivision. </div><div class="ttdef"><b>Definition:</b> <a href="_aide_g_l_8cpp_source.html#l00317">AideGL.cpp:317</a></div></div>
<div class="ttc" id="_utilitaire_8h_html"><div class="ttname"><a href="_utilitaire_8h.html">Utilitaire.h</a></div></div>
<div class="ttc" id="namespaceaidegl_html_a6bba7d34e4998b9c94fe5971ecf535c0"><div class="ttname"><a href="namespaceaidegl.html#a6bba7d34e4998b9c94fe5971ecf535c0">aidegl::glLoadTexture</a></div><div class="ttdeci">bool glLoadTexture(const std::string &amp;nomFichier, unsigned int &amp;idTexture, bool genererTexture)</div><div class="ttdoc">Charge une texture OpenGL à partir d&amp;#39;un fichier image. </div><div class="ttdef"><b>Definition:</b> <a href="_aide_g_l_8cpp_source.html#l00539">AideGL.cpp:539</a></div></div>
<div class="ttc" id="namespaceaidegl_html_a0680ab3e3bddc4c7b123c46117e31094"><div class="ttname"><a href="namespaceaidegl.html#a0680ab3e3bddc4c7b123c46117e31094">aidegl::initialiserRectangleElastique</a></div><div class="ttdeci">void initialiserRectangleElastique(const glm::ivec2 &amp;point, unsigned short patron, int facteur)</div><div class="ttdoc">Initialise le mode de rendu du rectangle élastique. </div><div class="ttdef"><b>Definition:</b> <a href="_aide_g_l_8cpp_source.html#l00149">AideGL.cpp:149</a></div></div>
<div class="ttc" id="namespaceutilitaire_html_ac61bdab36cf1cbaa0d06fa8b1f35ab64"><div class="ttname"><a href="namespaceutilitaire.html#ac61bdab36cf1cbaa0d06fa8b1f35ab64">utilitaire::afficherErreur</a></div><div class="ttdeci">void afficherErreur(const std::string &amp;message)</div><div class="ttdoc">Fonction globale pour l&amp;#39;affichage d&amp;#39;erreur. </div><div class="ttdef"><b>Definition:</b> <a href="_utilitaire_8cpp_source.html#l00039">Utilitaire.cpp:39</a></div></div>
<div class="ttc" id="namespaceaidegl_html_a19ef7b4b71b7a1568393cfc78be46a91"><div class="ttname"><a href="namespaceaidegl.html#a19ef7b4b71b7a1568393cfc78be46a91">aidegl::obtenirMessageErreur</a></div><div class="ttdeci">std::string obtenirMessageErreur(GLenum codeErreur, int drapeau)</div><div class="ttdoc">Retourne une chaîne correspondant au code d&amp;#39;erreur OpenGL. </div><div class="ttdef"><b>Definition:</b> <a href="_aide_g_l_8cpp_source.html#l00406">AideGL.cpp:406</a></div></div>
<div class="ttc" id="namespaceaidegl_html_af6f5a219dd414d647d8e4d92b6c30fd5"><div class="ttname"><a href="namespaceaidegl.html#af6f5a219dd414d647d8e4d92b6c30fd5">aidegl::glCreateTexture</a></div><div class="ttdeci">void glCreateTexture(unsigned char *data, int x, int y, int bpp, int pitch, unsigned int &amp;ID, bool genererTexture)</div><div class="ttdoc">Crée une texture à partir des pixels en mémoire. </div><div class="ttdef"><b>Definition:</b> <a href="_aide_g_l_8cpp_source.html#l00643">AideGL.cpp:643</a></div></div>
<div class="ttc" id="namespaceaidegl_html_a0cb31f11533480a059574970f5fcff6b"><div class="ttname"><a href="namespaceaidegl.html#a0cb31f11533480a059574970f5fcff6b">aidegl::detruireContexteGL</a></div><div class="ttdeci">bool detruireContexteGL(HWND hWnd, HDC hDC, HGLRC hRC)</div><div class="ttdoc">Détruit un contexte OpenGL. </div><div class="ttdef"><b>Definition:</b> <a href="_aide_g_l_8cpp_source.html#l00117">AideGL.cpp:117</a></div></div>
<div class="ttc" id="namespaceaidegl_html"><div class="ttname"><a href="namespaceaidegl.html">aidegl</a></div><div class="ttdef"><b>Definition:</b> <a href="_ligne_pointillee_8h_source.html#l00018">LignePointillee.h:18</a></div></div>
<div class="ttc" id="_aide_g_l_8h_html"><div class="ttname"><a href="_aide_g_l_8h.html">AideGL.h</a></div><div class="ttdoc">Ce fichier contient la déclaration de l&amp;#39;espace de nom aidegl. </div></div>
<div class="ttc" id="namespaceaidegl_html_a023f37325ede13a1f60243382cc11b12"><div class="ttname"><a href="namespaceaidegl.html#a023f37325ede13a1f60243382cc11b12">aidegl::terminerRectangleElastique</a></div><div class="ttdeci">void terminerRectangleElastique(const glm::ivec2 &amp;pointAncrage, const glm::ivec2 &amp;pointFinal)</div><div class="ttdoc">Termine le mode de rendu du rectangle élastique. </div><div class="ttdef"><b>Definition:</b> <a href="_aide_g_l_8cpp_source.html#l00267">AideGL.cpp:267</a></div></div>
<div class="ttc" id="namespaceaidegl_html_a923ac6c4f17f9d93b072c786e0f86d41"><div class="ttname"><a href="namespaceaidegl.html#a923ac6c4f17f9d93b072c786e0f86d41">aidegl::verifierErreurOpenGL</a></div><div class="ttdeci">void verifierErreurOpenGL(int drapeau)</div><div class="ttdoc">Vérifie s&amp;#39;il y a une erreur OpenGL. </div><div class="ttdef"><b>Definition:</b> <a href="_aide_g_l_8cpp_source.html#l00511">AideGL.cpp:511</a></div></div>
<div class="ttc" id="namespaceaidegl_html_a465185be937173fdd623eb88949b212c"><div class="ttname"><a href="namespaceaidegl.html#a465185be937173fdd623eb88949b212c">aidegl::creerContexteGL</a></div><div class="ttdeci">bool creerContexteGL(HWND hWnd, HDC &amp;hDC, HGLRC &amp;hRC)</div><div class="ttdoc">Crée un contexte OpenGL dans la fenêtre donnée. </div><div class="ttdef"><b>Definition:</b> <a href="_aide_g_l_8cpp_source.html#l00045">AideGL.cpp:45</a></div></div>
<div class="ttc" id="group__inf2990_html_gab927965981178aa1fba979a37168db2a"><div class="ttname"><a href="group__inf2990.html#gab927965981178aa1fba979a37168db2a">y</a></div><div class="ttdeci">int y</div><div class="ttdef"><b>Definition:</b> <a href="_facade_interface_native_8cpp_source.html#l00224">FacadeInterfaceNative.cpp:224</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_18175d1561e441e5475c63c8ef04b13d.html">Cadriciel</a></li><li class="navelem"><a class="el" href="dir_2fa3e292fa6870917468af5ba20aa5dc.html">Commun</a></li><li class="navelem"><a class="el" href="dir_66036a313aefac4406ec8f23b734b6a8.html">Utilitaire</a></li><li class="navelem"><a class="el" href="dir_c5a47c5fc8edd47298d40f6c40e3a762.html">OpenGL</a></li><li class="navelem"><a class="el" href="_aide_g_l_8cpp.html">AideGL.cpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
